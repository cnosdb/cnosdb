// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.MetricMetadata)
pub struct MetricMetadata {
    // message fields
    ///  Represents the metric type, these match the set from Prometheus.
    ///  Refer to model/textparse/interface.go for details.
    // @@protoc_insertion_point(field:prometheus.MetricMetadata.type)
    pub type_: ::protobuf::EnumOrUnknown<metric_metadata::MetricType>,
    // @@protoc_insertion_point(field:prometheus.MetricMetadata.metric_family_name)
    pub metric_family_name: ::std::string::String,
    // @@protoc_insertion_point(field:prometheus.MetricMetadata.help)
    pub help: ::std::string::String,
    // @@protoc_insertion_point(field:prometheus.MetricMetadata.unit)
    pub unit: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.MetricMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricMetadata {
    fn default() -> &'a MetricMetadata {
        <MetricMetadata as ::protobuf::Message>::default_instance()
    }
}

impl MetricMetadata {
    pub fn new() -> MetricMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MetricMetadata| { &m.type_ },
            |m: &mut MetricMetadata| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metric_family_name",
            |m: &MetricMetadata| { &m.metric_family_name },
            |m: &mut MetricMetadata| { &mut m.metric_family_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "help",
            |m: &MetricMetadata| { &m.help },
            |m: &mut MetricMetadata| { &mut m.help },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &MetricMetadata| { &m.unit },
            |m: &mut MetricMetadata| { &mut m.unit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricMetadata>(
            "MetricMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricMetadata {
    const NAME: &'static str = "MetricMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.metric_family_name = is.read_string()?;
                },
                34 => {
                    self.help = is.read_string()?;
                },
                42 => {
                    self.unit = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(metric_metadata::MetricType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.metric_family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.metric_family_name);
        }
        if !self.help.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.help);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.unit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(metric_metadata::MetricType::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.metric_family_name.is_empty() {
            os.write_string(2, &self.metric_family_name)?;
        }
        if !self.help.is_empty() {
            os.write_string(4, &self.help)?;
        }
        if !self.unit.is_empty() {
            os.write_string(5, &self.unit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricMetadata {
        MetricMetadata::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(metric_metadata::MetricType::UNKNOWN);
        self.metric_family_name.clear();
        self.help.clear();
        self.unit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricMetadata {
        static instance: MetricMetadata = MetricMetadata {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            metric_family_name: ::std::string::String::new(),
            help: ::std::string::String::new(),
            unit: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MetricMetadata`
pub mod metric_metadata {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:prometheus.MetricMetadata.MetricType)
    pub enum MetricType {
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.COUNTER)
        COUNTER = 1,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.GAUGE)
        GAUGE = 2,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.HISTOGRAM)
        HISTOGRAM = 3,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.GAUGEHISTOGRAM)
        GAUGEHISTOGRAM = 4,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.SUMMARY)
        SUMMARY = 5,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.INFO)
        INFO = 6,
        // @@protoc_insertion_point(enum_value:prometheus.MetricMetadata.MetricType.STATESET)
        STATESET = 7,
    }

    impl ::protobuf::Enum for MetricType {
        const NAME: &'static str = "MetricType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MetricType> {
            match value {
                0 => ::std::option::Option::Some(MetricType::UNKNOWN),
                1 => ::std::option::Option::Some(MetricType::COUNTER),
                2 => ::std::option::Option::Some(MetricType::GAUGE),
                3 => ::std::option::Option::Some(MetricType::HISTOGRAM),
                4 => ::std::option::Option::Some(MetricType::GAUGEHISTOGRAM),
                5 => ::std::option::Option::Some(MetricType::SUMMARY),
                6 => ::std::option::Option::Some(MetricType::INFO),
                7 => ::std::option::Option::Some(MetricType::STATESET),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MetricType] = &[
            MetricType::UNKNOWN,
            MetricType::COUNTER,
            MetricType::GAUGE,
            MetricType::HISTOGRAM,
            MetricType::GAUGEHISTOGRAM,
            MetricType::SUMMARY,
            MetricType::INFO,
            MetricType::STATESET,
        ];
    }

    impl ::protobuf::EnumFull for MetricType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MetricMetadata.MetricType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MetricType {
        fn default() -> Self {
            MetricType::UNKNOWN
        }
    }

    impl MetricType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MetricType>("MetricMetadata.MetricType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Sample)
pub struct Sample {
    // message fields
    // @@protoc_insertion_point(field:prometheus.Sample.value)
    pub value: f64,
    ///  timestamp is in ms format, see model/timestamp/timestamp.go for
    ///  conversion from time.Time to Prometheus timestamp.
    // @@protoc_insertion_point(field:prometheus.Sample.timestamp)
    pub timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Sample.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sample {
    fn default() -> &'a Sample {
        <Sample as ::protobuf::Message>::default_instance()
    }
}

impl Sample {
    pub fn new() -> Sample {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Sample| { &m.value },
            |m: &mut Sample| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Sample| { &m.timestamp },
            |m: &mut Sample| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sample>(
            "Sample",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sample {
    const NAME: &'static str = "Sample";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                16 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sample {
        Sample::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sample {
        static instance: Sample = Sample {
            value: 0.,
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sample {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sample").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sample {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Exemplar)
pub struct Exemplar {
    // message fields
    ///  Optional, can be empty.
    // @@protoc_insertion_point(field:prometheus.Exemplar.labels)
    pub labels: ::std::vec::Vec<Label>,
    // @@protoc_insertion_point(field:prometheus.Exemplar.value)
    pub value: f64,
    ///  timestamp is in ms format, see model/timestamp/timestamp.go for
    ///  conversion from time.Time to Prometheus timestamp.
    // @@protoc_insertion_point(field:prometheus.Exemplar.timestamp)
    pub timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Exemplar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Exemplar {
    fn default() -> &'a Exemplar {
        <Exemplar as ::protobuf::Message>::default_instance()
    }
}

impl Exemplar {
    pub fn new() -> Exemplar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &Exemplar| { &m.labels },
            |m: &mut Exemplar| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Exemplar| { &m.value },
            |m: &mut Exemplar| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Exemplar| { &m.timestamp },
            |m: &mut Exemplar| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exemplar>(
            "Exemplar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Exemplar {
    const NAME: &'static str = "Exemplar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labels.push(is.read_message()?);
                },
                17 => {
                    self.value = is.read_double()?;
                },
                24 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.labels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Exemplar {
        Exemplar::new()
    }

    fn clear(&mut self) {
        self.labels.clear();
        self.value = 0.;
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Exemplar {
        static instance: Exemplar = Exemplar {
            labels: ::std::vec::Vec::new(),
            value: 0.,
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Exemplar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Exemplar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Exemplar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exemplar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A native histogram, also known as a sparse histogram.
///  Original design doc:
///  https://docs.google.com/document/d/1cLNv3aufPZb3fNfaJgdaRBZsInZKKIHo9E6HinJVbpM/edit
///  The appendix of this design doc also explains the concept of float
///  histograms. This Histogram message can represent both, the usual
///  integer histogram as well as a float histogram.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Histogram)
pub struct Histogram {
    // message fields
    // @@protoc_insertion_point(field:prometheus.Histogram.sum)
    pub sum: f64,
    ///  The schema defines the bucket schema. Currently, valid numbers
    ///  are -4 <= n <= 8. They are all for base-2 bucket schemas, where 1
    ///  is a bucket boundary in each case, and then each power of two is
    ///  divided into 2^n logarithmic buckets. Or in other words, each
    ///  bucket boundary is the previous boundary times 2^(2^-n). In the
    ///  future, more bucket schemas may be added using numbers < -4 or >
    ///  8.
    // @@protoc_insertion_point(field:prometheus.Histogram.schema)
    pub schema: i32,
    // @@protoc_insertion_point(field:prometheus.Histogram.zero_threshold)
    pub zero_threshold: f64,
    ///  Negative Buckets.
    // @@protoc_insertion_point(field:prometheus.Histogram.negative_spans)
    pub negative_spans: ::std::vec::Vec<BucketSpan>,
    ///  Use either "negative_deltas" or "negative_counts", the former for
    ///  regular histograms with integer counts, the latter for float
    ///  histograms.
    // @@protoc_insertion_point(field:prometheus.Histogram.negative_deltas)
    pub negative_deltas: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:prometheus.Histogram.negative_counts)
    pub negative_counts: ::std::vec::Vec<f64>,
    ///  Positive Buckets.
    // @@protoc_insertion_point(field:prometheus.Histogram.positive_spans)
    pub positive_spans: ::std::vec::Vec<BucketSpan>,
    ///  Use either "positive_deltas" or "positive_counts", the former for
    ///  regular histograms with integer counts, the latter for float
    ///  histograms.
    // @@protoc_insertion_point(field:prometheus.Histogram.positive_deltas)
    pub positive_deltas: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:prometheus.Histogram.positive_counts)
    pub positive_counts: ::std::vec::Vec<f64>,
    // @@protoc_insertion_point(field:prometheus.Histogram.reset_hint)
    pub reset_hint: ::protobuf::EnumOrUnknown<histogram::ResetHint>,
    ///  timestamp is in ms format, see model/timestamp/timestamp.go for
    ///  conversion from time.Time to Prometheus timestamp.
    // @@protoc_insertion_point(field:prometheus.Histogram.timestamp)
    pub timestamp: i64,
    // message oneof groups
    pub count: ::std::option::Option<histogram::Count>,
    pub zero_count: ::std::option::Option<histogram::Zero_count>,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Histogram.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Histogram {
    fn default() -> &'a Histogram {
        <Histogram as ::protobuf::Message>::default_instance()
    }
}

impl Histogram {
    pub fn new() -> Histogram {
        ::std::default::Default::default()
    }

    // uint64 count_int = 1;

    pub fn count_int(&self) -> u64 {
        match self.count {
            ::std::option::Option::Some(histogram::Count::CountInt(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_count_int(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count_int(&self) -> bool {
        match self.count {
            ::std::option::Option::Some(histogram::Count::CountInt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_count_int(&mut self, v: u64) {
        self.count = ::std::option::Option::Some(histogram::Count::CountInt(v))
    }

    // double count_float = 2;

    pub fn count_float(&self) -> f64 {
        match self.count {
            ::std::option::Option::Some(histogram::Count::CountFloat(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_count_float(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count_float(&self) -> bool {
        match self.count {
            ::std::option::Option::Some(histogram::Count::CountFloat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_count_float(&mut self, v: f64) {
        self.count = ::std::option::Option::Some(histogram::Count::CountFloat(v))
    }

    // uint64 zero_count_int = 6;

    pub fn zero_count_int(&self) -> u64 {
        match self.zero_count {
            ::std::option::Option::Some(histogram::Zero_count::ZeroCountInt(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_zero_count_int(&mut self) {
        self.zero_count = ::std::option::Option::None;
    }

    pub fn has_zero_count_int(&self) -> bool {
        match self.zero_count {
            ::std::option::Option::Some(histogram::Zero_count::ZeroCountInt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_zero_count_int(&mut self, v: u64) {
        self.zero_count = ::std::option::Option::Some(histogram::Zero_count::ZeroCountInt(v))
    }

    // double zero_count_float = 7;

    pub fn zero_count_float(&self) -> f64 {
        match self.zero_count {
            ::std::option::Option::Some(histogram::Zero_count::ZeroCountFloat(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_zero_count_float(&mut self) {
        self.zero_count = ::std::option::Option::None;
    }

    pub fn has_zero_count_float(&self) -> bool {
        match self.zero_count {
            ::std::option::Option::Some(histogram::Zero_count::ZeroCountFloat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_zero_count_float(&mut self, v: f64) {
        self.zero_count = ::std::option::Option::Some(histogram::Zero_count::ZeroCountFloat(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "count_int",
            Histogram::has_count_int,
            Histogram::count_int,
            Histogram::set_count_int,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "count_float",
            Histogram::has_count_float,
            Histogram::count_float,
            Histogram::set_count_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sum",
            |m: &Histogram| { &m.sum },
            |m: &mut Histogram| { &mut m.sum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema",
            |m: &Histogram| { &m.schema },
            |m: &mut Histogram| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zero_threshold",
            |m: &Histogram| { &m.zero_threshold },
            |m: &mut Histogram| { &mut m.zero_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "zero_count_int",
            Histogram::has_zero_count_int,
            Histogram::zero_count_int,
            Histogram::set_zero_count_int,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "zero_count_float",
            Histogram::has_zero_count_float,
            Histogram::zero_count_float,
            Histogram::set_zero_count_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "negative_spans",
            |m: &Histogram| { &m.negative_spans },
            |m: &mut Histogram| { &mut m.negative_spans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "negative_deltas",
            |m: &Histogram| { &m.negative_deltas },
            |m: &mut Histogram| { &mut m.negative_deltas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "negative_counts",
            |m: &Histogram| { &m.negative_counts },
            |m: &mut Histogram| { &mut m.negative_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positive_spans",
            |m: &Histogram| { &m.positive_spans },
            |m: &mut Histogram| { &mut m.positive_spans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positive_deltas",
            |m: &Histogram| { &m.positive_deltas },
            |m: &mut Histogram| { &mut m.positive_deltas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positive_counts",
            |m: &Histogram| { &m.positive_counts },
            |m: &mut Histogram| { &mut m.positive_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reset_hint",
            |m: &Histogram| { &m.reset_hint },
            |m: &mut Histogram| { &mut m.reset_hint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Histogram| { &m.timestamp },
            |m: &mut Histogram| { &mut m.timestamp },
        ));
        oneofs.push(histogram::Count::generated_oneof_descriptor_data());
        oneofs.push(histogram::Zero_count::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Histogram>(
            "Histogram",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Histogram {
    const NAME: &'static str = "Histogram";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(histogram::Count::CountInt(is.read_uint64()?));
                },
                17 => {
                    self.count = ::std::option::Option::Some(histogram::Count::CountFloat(is.read_double()?));
                },
                25 => {
                    self.sum = is.read_double()?;
                },
                32 => {
                    self.schema = is.read_sint32()?;
                },
                41 => {
                    self.zero_threshold = is.read_double()?;
                },
                48 => {
                    self.zero_count = ::std::option::Option::Some(histogram::Zero_count::ZeroCountInt(is.read_uint64()?));
                },
                57 => {
                    self.zero_count = ::std::option::Option::Some(histogram::Zero_count::ZeroCountFloat(is.read_double()?));
                },
                66 => {
                    self.negative_spans.push(is.read_message()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.negative_deltas)?;
                },
                72 => {
                    self.negative_deltas.push(is.read_sint64()?);
                },
                82 => {
                    is.read_repeated_packed_double_into(&mut self.negative_counts)?;
                },
                81 => {
                    self.negative_counts.push(is.read_double()?);
                },
                90 => {
                    self.positive_spans.push(is.read_message()?);
                },
                98 => {
                    is.read_repeated_packed_sint64_into(&mut self.positive_deltas)?;
                },
                96 => {
                    self.positive_deltas.push(is.read_sint64()?);
                },
                106 => {
                    is.read_repeated_packed_double_into(&mut self.positive_counts)?;
                },
                105 => {
                    self.positive_counts.push(is.read_double()?);
                },
                112 => {
                    self.reset_hint = is.read_enum_or_unknown()?;
                },
                120 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sum != 0. {
            my_size += 1 + 8;
        }
        if self.schema != 0 {
            my_size += ::protobuf::rt::sint32_size(4, self.schema);
        }
        if self.zero_threshold != 0. {
            my_size += 1 + 8;
        }
        for value in &self.negative_spans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.negative_deltas {
            my_size += ::protobuf::rt::sint64_size(9, *value);
        };
        my_size += 9 * self.negative_counts.len() as u64;
        for value in &self.positive_spans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.positive_deltas {
            my_size += ::protobuf::rt::sint64_size(12, *value);
        };
        my_size += 9 * self.positive_counts.len() as u64;
        if self.reset_hint != ::protobuf::EnumOrUnknown::new(histogram::ResetHint::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(14, self.reset_hint.value());
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(15, self.timestamp);
        }
        if let ::std::option::Option::Some(ref v) = self.count {
            match v {
                &histogram::Count::CountInt(v) => {
                    my_size += ::protobuf::rt::uint64_size(1, v);
                },
                &histogram::Count::CountFloat(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.zero_count {
            match v {
                &histogram::Zero_count::ZeroCountInt(v) => {
                    my_size += ::protobuf::rt::uint64_size(6, v);
                },
                &histogram::Zero_count::ZeroCountFloat(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sum != 0. {
            os.write_double(3, self.sum)?;
        }
        if self.schema != 0 {
            os.write_sint32(4, self.schema)?;
        }
        if self.zero_threshold != 0. {
            os.write_double(5, self.zero_threshold)?;
        }
        for v in &self.negative_spans {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.negative_deltas {
            os.write_sint64(9, *v)?;
        };
        for v in &self.negative_counts {
            os.write_double(10, *v)?;
        };
        for v in &self.positive_spans {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.positive_deltas {
            os.write_sint64(12, *v)?;
        };
        for v in &self.positive_counts {
            os.write_double(13, *v)?;
        };
        if self.reset_hint != ::protobuf::EnumOrUnknown::new(histogram::ResetHint::UNKNOWN) {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&self.reset_hint))?;
        }
        if self.timestamp != 0 {
            os.write_int64(15, self.timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.count {
            match v {
                &histogram::Count::CountInt(v) => {
                    os.write_uint64(1, v)?;
                },
                &histogram::Count::CountFloat(v) => {
                    os.write_double(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.zero_count {
            match v {
                &histogram::Zero_count::ZeroCountInt(v) => {
                    os.write_uint64(6, v)?;
                },
                &histogram::Zero_count::ZeroCountFloat(v) => {
                    os.write_double(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Histogram {
        Histogram::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.sum = 0.;
        self.schema = 0;
        self.zero_threshold = 0.;
        self.zero_count = ::std::option::Option::None;
        self.zero_count = ::std::option::Option::None;
        self.negative_spans.clear();
        self.negative_deltas.clear();
        self.negative_counts.clear();
        self.positive_spans.clear();
        self.positive_deltas.clear();
        self.positive_counts.clear();
        self.reset_hint = ::protobuf::EnumOrUnknown::new(histogram::ResetHint::UNKNOWN);
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Histogram {
        static instance: Histogram = Histogram {
            sum: 0.,
            schema: 0,
            zero_threshold: 0.,
            negative_spans: ::std::vec::Vec::new(),
            negative_deltas: ::std::vec::Vec::new(),
            negative_counts: ::std::vec::Vec::new(),
            positive_spans: ::std::vec::Vec::new(),
            positive_deltas: ::std::vec::Vec::new(),
            positive_counts: ::std::vec::Vec::new(),
            reset_hint: ::protobuf::EnumOrUnknown::from_i32(0),
            timestamp: 0,
            count: ::std::option::Option::None,
            zero_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Histogram {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Histogram").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Histogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Histogram {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Histogram`
pub mod histogram {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:prometheus.Histogram.count)
    pub enum Count {
        // @@protoc_insertion_point(oneof_field:prometheus.Histogram.count_int)
        CountInt(u64),
        // @@protoc_insertion_point(oneof_field:prometheus.Histogram.count_float)
        CountFloat(f64),
    }

    impl ::protobuf::Oneof for Count {
    }

    impl ::protobuf::OneofFull for Count {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Histogram as ::protobuf::MessageFull>::descriptor().oneof_by_name("count").unwrap()).clone()
        }
    }

    impl Count {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Count>("count")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:prometheus.Histogram.zero_count)
    pub enum Zero_count {
        // @@protoc_insertion_point(oneof_field:prometheus.Histogram.zero_count_int)
        ZeroCountInt(u64),
        // @@protoc_insertion_point(oneof_field:prometheus.Histogram.zero_count_float)
        ZeroCountFloat(f64),
    }

    impl ::protobuf::Oneof for Zero_count {
    }

    impl ::protobuf::OneofFull for Zero_count {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Histogram as ::protobuf::MessageFull>::descriptor().oneof_by_name("zero_count").unwrap()).clone()
        }
    }

    impl Zero_count {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Zero_count>("zero_count")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:prometheus.Histogram.ResetHint)
    pub enum ResetHint {
        // @@protoc_insertion_point(enum_value:prometheus.Histogram.ResetHint.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:prometheus.Histogram.ResetHint.YES)
        YES = 1,
        // @@protoc_insertion_point(enum_value:prometheus.Histogram.ResetHint.NO)
        NO = 2,
        // @@protoc_insertion_point(enum_value:prometheus.Histogram.ResetHint.GAUGE)
        GAUGE = 3,
    }

    impl ::protobuf::Enum for ResetHint {
        const NAME: &'static str = "ResetHint";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ResetHint> {
            match value {
                0 => ::std::option::Option::Some(ResetHint::UNKNOWN),
                1 => ::std::option::Option::Some(ResetHint::YES),
                2 => ::std::option::Option::Some(ResetHint::NO),
                3 => ::std::option::Option::Some(ResetHint::GAUGE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ResetHint] = &[
            ResetHint::UNKNOWN,
            ResetHint::YES,
            ResetHint::NO,
            ResetHint::GAUGE,
        ];
    }

    impl ::protobuf::EnumFull for ResetHint {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Histogram.ResetHint").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ResetHint {
        fn default() -> Self {
            ResetHint::UNKNOWN
        }
    }

    impl ResetHint {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResetHint>("Histogram.ResetHint")
        }
    }
}

///  A BucketSpan defines a number of consecutive buckets with their
///  offset. Logically, it would be more straightforward to include the
///  bucket counts in the Span. However, the protobuf representation is
///  more compact in the way the data is structured here (with all the
///  buckets in a single array separate from the Spans).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.BucketSpan)
pub struct BucketSpan {
    // message fields
    // @@protoc_insertion_point(field:prometheus.BucketSpan.offset)
    pub offset: i32,
    // @@protoc_insertion_point(field:prometheus.BucketSpan.length)
    pub length: u32,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.BucketSpan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BucketSpan {
    fn default() -> &'a BucketSpan {
        <BucketSpan as ::protobuf::Message>::default_instance()
    }
}

impl BucketSpan {
    pub fn new() -> BucketSpan {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &BucketSpan| { &m.offset },
            |m: &mut BucketSpan| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &BucketSpan| { &m.length },
            |m: &mut BucketSpan| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BucketSpan>(
            "BucketSpan",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BucketSpan {
    const NAME: &'static str = "BucketSpan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset = is.read_sint32()?;
                },
                16 => {
                    self.length = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.offset);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.length);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.offset != 0 {
            os.write_sint32(1, self.offset)?;
        }
        if self.length != 0 {
            os.write_uint32(2, self.length)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BucketSpan {
        BucketSpan::new()
    }

    fn clear(&mut self) {
        self.offset = 0;
        self.length = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BucketSpan {
        static instance: BucketSpan = BucketSpan {
            offset: 0,
            length: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BucketSpan {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BucketSpan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BucketSpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketSpan {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TimeSeries represents samples and labels for a single time series.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.TimeSeries)
pub struct TimeSeries {
    // message fields
    ///  For a timeseries to be valid, and for the samples and exemplars
    ///  to be ingested by the remote system properly, the labels field is required.
    // @@protoc_insertion_point(field:prometheus.TimeSeries.labels)
    pub labels: ::std::vec::Vec<Label>,
    // @@protoc_insertion_point(field:prometheus.TimeSeries.samples)
    pub samples: ::std::vec::Vec<Sample>,
    // @@protoc_insertion_point(field:prometheus.TimeSeries.exemplars)
    pub exemplars: ::std::vec::Vec<Exemplar>,
    // @@protoc_insertion_point(field:prometheus.TimeSeries.histograms)
    pub histograms: ::std::vec::Vec<Histogram>,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.TimeSeries.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeSeries {
    fn default() -> &'a TimeSeries {
        <TimeSeries as ::protobuf::Message>::default_instance()
    }
}

impl TimeSeries {
    pub fn new() -> TimeSeries {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &TimeSeries| { &m.labels },
            |m: &mut TimeSeries| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "samples",
            |m: &TimeSeries| { &m.samples },
            |m: &mut TimeSeries| { &mut m.samples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exemplars",
            |m: &TimeSeries| { &m.exemplars },
            |m: &mut TimeSeries| { &mut m.exemplars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "histograms",
            |m: &TimeSeries| { &m.histograms },
            |m: &mut TimeSeries| { &mut m.histograms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeSeries>(
            "TimeSeries",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeSeries {
    const NAME: &'static str = "TimeSeries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labels.push(is.read_message()?);
                },
                18 => {
                    self.samples.push(is.read_message()?);
                },
                26 => {
                    self.exemplars.push(is.read_message()?);
                },
                34 => {
                    self.histograms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exemplars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.histograms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.labels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.samples {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.exemplars {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.histograms {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeSeries {
        TimeSeries::new()
    }

    fn clear(&mut self) {
        self.labels.clear();
        self.samples.clear();
        self.exemplars.clear();
        self.histograms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeSeries {
        static instance: TimeSeries = TimeSeries {
            labels: ::std::vec::Vec::new(),
            samples: ::std::vec::Vec::new(),
            exemplars: ::std::vec::Vec::new(),
            histograms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeSeries {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeSeries").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeSeries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSeries {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Label)
pub struct Label {
    // message fields
    // @@protoc_insertion_point(field:prometheus.Label.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:prometheus.Label.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Label.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Label {
    fn default() -> &'a Label {
        <Label as ::protobuf::Message>::default_instance()
    }
}

impl Label {
    pub fn new() -> Label {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Label| { &m.name },
            |m: &mut Label| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Label| { &m.value },
            |m: &mut Label| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Label>(
            "Label",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Label {
    const NAME: &'static str = "Label";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Label {
        Label::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Label {
        static instance: Label = Label {
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Label {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Label").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Label {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Label {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Labels)
pub struct Labels {
    // message fields
    // @@protoc_insertion_point(field:prometheus.Labels.labels)
    pub labels: ::std::vec::Vec<Label>,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Labels.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Labels {
    fn default() -> &'a Labels {
        <Labels as ::protobuf::Message>::default_instance()
    }
}

impl Labels {
    pub fn new() -> Labels {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &Labels| { &m.labels },
            |m: &mut Labels| { &mut m.labels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Labels>(
            "Labels",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Labels {
    const NAME: &'static str = "Labels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.labels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Labels {
        Labels::new()
    }

    fn clear(&mut self) {
        self.labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Labels {
        static instance: Labels = Labels {
            labels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Labels {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Labels").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Labels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Labels {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Matcher specifies a rule, which can match or set of labels or not.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.LabelMatcher)
pub struct LabelMatcher {
    // message fields
    // @@protoc_insertion_point(field:prometheus.LabelMatcher.type)
    pub type_: ::protobuf::EnumOrUnknown<label_matcher::Type>,
    // @@protoc_insertion_point(field:prometheus.LabelMatcher.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:prometheus.LabelMatcher.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.LabelMatcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelMatcher {
    fn default() -> &'a LabelMatcher {
        <LabelMatcher as ::protobuf::Message>::default_instance()
    }
}

impl LabelMatcher {
    pub fn new() -> LabelMatcher {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &LabelMatcher| { &m.type_ },
            |m: &mut LabelMatcher| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LabelMatcher| { &m.name },
            |m: &mut LabelMatcher| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &LabelMatcher| { &m.value },
            |m: &mut LabelMatcher| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelMatcher>(
            "LabelMatcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelMatcher {
    const NAME: &'static str = "LabelMatcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(label_matcher::Type::EQ) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(label_matcher::Type::EQ) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelMatcher {
        LabelMatcher::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(label_matcher::Type::EQ);
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelMatcher {
        static instance: LabelMatcher = LabelMatcher {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelMatcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelMatcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelMatcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LabelMatcher`
pub mod label_matcher {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:prometheus.LabelMatcher.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:prometheus.LabelMatcher.Type.EQ)
        EQ = 0,
        // @@protoc_insertion_point(enum_value:prometheus.LabelMatcher.Type.NEQ)
        NEQ = 1,
        // @@protoc_insertion_point(enum_value:prometheus.LabelMatcher.Type.RE)
        RE = 2,
        // @@protoc_insertion_point(enum_value:prometheus.LabelMatcher.Type.NRE)
        NRE = 3,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::EQ),
                1 => ::std::option::Option::Some(Type::NEQ),
                2 => ::std::option::Option::Some(Type::RE),
                3 => ::std::option::Option::Some(Type::NRE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::EQ,
            Type::NEQ,
            Type::RE,
            Type::NRE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("LabelMatcher.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::EQ
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("LabelMatcher.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.ReadHints)
pub struct ReadHints {
    // message fields
    // @@protoc_insertion_point(field:prometheus.ReadHints.step_ms)
    pub step_ms: i64,
    // @@protoc_insertion_point(field:prometheus.ReadHints.func)
    pub func: ::std::string::String,
    // @@protoc_insertion_point(field:prometheus.ReadHints.start_ms)
    pub start_ms: i64,
    // @@protoc_insertion_point(field:prometheus.ReadHints.end_ms)
    pub end_ms: i64,
    // @@protoc_insertion_point(field:prometheus.ReadHints.grouping)
    pub grouping: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:prometheus.ReadHints.by)
    pub by: bool,
    // @@protoc_insertion_point(field:prometheus.ReadHints.range_ms)
    pub range_ms: i64,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.ReadHints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadHints {
    fn default() -> &'a ReadHints {
        <ReadHints as ::protobuf::Message>::default_instance()
    }
}

impl ReadHints {
    pub fn new() -> ReadHints {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step_ms",
            |m: &ReadHints| { &m.step_ms },
            |m: &mut ReadHints| { &mut m.step_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "func",
            |m: &ReadHints| { &m.func },
            |m: &mut ReadHints| { &mut m.func },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_ms",
            |m: &ReadHints| { &m.start_ms },
            |m: &mut ReadHints| { &mut m.start_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_ms",
            |m: &ReadHints| { &m.end_ms },
            |m: &mut ReadHints| { &mut m.end_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grouping",
            |m: &ReadHints| { &m.grouping },
            |m: &mut ReadHints| { &mut m.grouping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "by",
            |m: &ReadHints| { &m.by },
            |m: &mut ReadHints| { &mut m.by },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "range_ms",
            |m: &ReadHints| { &m.range_ms },
            |m: &mut ReadHints| { &mut m.range_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadHints>(
            "ReadHints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadHints {
    const NAME: &'static str = "ReadHints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.step_ms = is.read_int64()?;
                },
                18 => {
                    self.func = is.read_string()?;
                },
                24 => {
                    self.start_ms = is.read_int64()?;
                },
                32 => {
                    self.end_ms = is.read_int64()?;
                },
                42 => {
                    self.grouping.push(is.read_string()?);
                },
                48 => {
                    self.by = is.read_bool()?;
                },
                56 => {
                    self.range_ms = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.step_ms != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.step_ms);
        }
        if !self.func.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.func);
        }
        if self.start_ms != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.start_ms);
        }
        if self.end_ms != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.end_ms);
        }
        for value in &self.grouping {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.by != false {
            my_size += 1 + 1;
        }
        if self.range_ms != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.range_ms);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.step_ms != 0 {
            os.write_int64(1, self.step_ms)?;
        }
        if !self.func.is_empty() {
            os.write_string(2, &self.func)?;
        }
        if self.start_ms != 0 {
            os.write_int64(3, self.start_ms)?;
        }
        if self.end_ms != 0 {
            os.write_int64(4, self.end_ms)?;
        }
        for v in &self.grouping {
            os.write_string(5, &v)?;
        };
        if self.by != false {
            os.write_bool(6, self.by)?;
        }
        if self.range_ms != 0 {
            os.write_int64(7, self.range_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadHints {
        ReadHints::new()
    }

    fn clear(&mut self) {
        self.step_ms = 0;
        self.func.clear();
        self.start_ms = 0;
        self.end_ms = 0;
        self.grouping.clear();
        self.by = false;
        self.range_ms = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadHints {
        static instance: ReadHints = ReadHints {
            step_ms: 0,
            func: ::std::string::String::new(),
            start_ms: 0,
            end_ms: 0,
            grouping: ::std::vec::Vec::new(),
            by: false,
            range_ms: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadHints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadHints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadHints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadHints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Chunk represents a TSDB chunk.
///  Time range [min, max] is inclusive.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.Chunk)
pub struct Chunk {
    // message fields
    // @@protoc_insertion_point(field:prometheus.Chunk.min_time_ms)
    pub min_time_ms: i64,
    // @@protoc_insertion_point(field:prometheus.Chunk.max_time_ms)
    pub max_time_ms: i64,
    // @@protoc_insertion_point(field:prometheus.Chunk.type)
    pub type_: ::protobuf::EnumOrUnknown<chunk::Encoding>,
    // @@protoc_insertion_point(field:prometheus.Chunk.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.Chunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Chunk {
    fn default() -> &'a Chunk {
        <Chunk as ::protobuf::Message>::default_instance()
    }
}

impl Chunk {
    pub fn new() -> Chunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_time_ms",
            |m: &Chunk| { &m.min_time_ms },
            |m: &mut Chunk| { &mut m.min_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_time_ms",
            |m: &Chunk| { &m.max_time_ms },
            |m: &mut Chunk| { &mut m.max_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Chunk| { &m.type_ },
            |m: &mut Chunk| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Chunk| { &m.data },
            |m: &mut Chunk| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Chunk>(
            "Chunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Chunk {
    const NAME: &'static str = "Chunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min_time_ms = is.read_int64()?;
                },
                16 => {
                    self.max_time_ms = is.read_int64()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.min_time_ms != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.min_time_ms);
        }
        if self.max_time_ms != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.max_time_ms);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(chunk::Encoding::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.min_time_ms != 0 {
            os.write_int64(1, self.min_time_ms)?;
        }
        if self.max_time_ms != 0 {
            os.write_int64(2, self.max_time_ms)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(chunk::Encoding::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Chunk {
        Chunk::new()
    }

    fn clear(&mut self) {
        self.min_time_ms = 0;
        self.max_time_ms = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(chunk::Encoding::UNKNOWN);
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Chunk {
        static instance: Chunk = Chunk {
            min_time_ms: 0,
            max_time_ms: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Chunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Chunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Chunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Chunk`
pub mod chunk {
    ///  We require this to match chunkenc.Encoding.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:prometheus.Chunk.Encoding)
    pub enum Encoding {
        // @@protoc_insertion_point(enum_value:prometheus.Chunk.Encoding.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:prometheus.Chunk.Encoding.XOR)
        XOR = 1,
        // @@protoc_insertion_point(enum_value:prometheus.Chunk.Encoding.HISTOGRAM)
        HISTOGRAM = 2,
    }

    impl ::protobuf::Enum for Encoding {
        const NAME: &'static str = "Encoding";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Encoding> {
            match value {
                0 => ::std::option::Option::Some(Encoding::UNKNOWN),
                1 => ::std::option::Option::Some(Encoding::XOR),
                2 => ::std::option::Option::Some(Encoding::HISTOGRAM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Encoding] = &[
            Encoding::UNKNOWN,
            Encoding::XOR,
            Encoding::HISTOGRAM,
        ];
    }

    impl ::protobuf::EnumFull for Encoding {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Chunk.Encoding").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Encoding {
        fn default() -> Self {
            Encoding::UNKNOWN
        }
    }

    impl Encoding {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Encoding>("Chunk.Encoding")
        }
    }
}

///  ChunkedSeries represents single, encoded time series.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:prometheus.ChunkedSeries)
pub struct ChunkedSeries {
    // message fields
    ///  Labels should be sorted.
    // @@protoc_insertion_point(field:prometheus.ChunkedSeries.labels)
    pub labels: ::std::vec::Vec<Label>,
    ///  Chunks will be in start time order and may overlap.
    // @@protoc_insertion_point(field:prometheus.ChunkedSeries.chunks)
    pub chunks: ::std::vec::Vec<Chunk>,
    // special fields
    // @@protoc_insertion_point(special_field:prometheus.ChunkedSeries.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChunkedSeries {
    fn default() -> &'a ChunkedSeries {
        <ChunkedSeries as ::protobuf::Message>::default_instance()
    }
}

impl ChunkedSeries {
    pub fn new() -> ChunkedSeries {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &ChunkedSeries| { &m.labels },
            |m: &mut ChunkedSeries| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chunks",
            |m: &ChunkedSeries| { &m.chunks },
            |m: &mut ChunkedSeries| { &mut m.chunks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChunkedSeries>(
            "ChunkedSeries",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChunkedSeries {
    const NAME: &'static str = "ChunkedSeries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labels.push(is.read_message()?);
                },
                18 => {
                    self.chunks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.labels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.chunks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChunkedSeries {
        ChunkedSeries::new()
    }

    fn clear(&mut self) {
        self.labels.clear();
        self.chunks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChunkedSeries {
        static instance: ChunkedSeries = ChunkedSeries {
            labels: ::std::vec::Vec::new(),
            chunks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChunkedSeries {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChunkedSeries").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChunkedSeries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChunkedSeries {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0btypes.proto\x12\nprometheus\x1a\x14gogoproto/gogo.proto\"\x9c\x02\
    \n\x0eMetricMetadata\x129\n\x04type\x18\x01\x20\x01(\x0e2%.prometheus.Me\
    tricMetadata.MetricTypeR\x04type\x12,\n\x12metric_family_name\x18\x02\
    \x20\x01(\tR\x10metricFamilyName\x12\x12\n\x04help\x18\x04\x20\x01(\tR\
    \x04help\x12\x12\n\x04unit\x18\x05\x20\x01(\tR\x04unit\"y\n\nMetricType\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07COUNTER\x10\x01\x12\t\n\x05GAUG\
    E\x10\x02\x12\r\n\tHISTOGRAM\x10\x03\x12\x12\n\x0eGAUGEHISTOGRAM\x10\x04\
    \x12\x0b\n\x07SUMMARY\x10\x05\x12\x08\n\x04INFO\x10\x06\x12\x0c\n\x08STA\
    TESET\x10\x07\"<\n\x06Sample\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\
    \x05value\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\"o\n\x08\
    Exemplar\x12/\n\x06labels\x18\x01\x20\x03(\x0b2\x11.prometheus.LabelR\
    \x06labelsB\x04\xc8\xde\x1f\0\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\
    \x05value\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\"\xbf\
    \x05\n\tHistogram\x12\x1d\n\tcount_int\x18\x01\x20\x01(\x04H\0R\x08count\
    Int\x12!\n\x0bcount_float\x18\x02\x20\x01(\x01H\0R\ncountFloat\x12\x10\n\
    \x03sum\x18\x03\x20\x01(\x01R\x03sum\x12\x16\n\x06schema\x18\x04\x20\x01\
    (\x11R\x06schema\x12%\n\x0ezero_threshold\x18\x05\x20\x01(\x01R\rzeroThr\
    eshold\x12&\n\x0ezero_count_int\x18\x06\x20\x01(\x04H\x01R\x0czeroCountI\
    nt\x12*\n\x10zero_count_float\x18\x07\x20\x01(\x01H\x01R\x0ezeroCountFlo\
    at\x12=\n\x0enegative_spans\x18\x08\x20\x03(\x0b2\x16.prometheus.BucketS\
    panR\rnegativeSpans\x12'\n\x0fnegative_deltas\x18\t\x20\x03(\x12R\x0eneg\
    ativeDeltas\x12'\n\x0fnegative_counts\x18\n\x20\x03(\x01R\x0enegativeCou\
    nts\x12=\n\x0epositive_spans\x18\x0b\x20\x03(\x0b2\x16.prometheus.Bucket\
    SpanR\rpositiveSpans\x12'\n\x0fpositive_deltas\x18\x0c\x20\x03(\x12R\x0e\
    positiveDeltas\x12'\n\x0fpositive_counts\x18\r\x20\x03(\x01R\x0epositive\
    Counts\x12>\n\nreset_hint\x18\x0e\x20\x01(\x0e2\x1f.prometheus.Histogram\
    .ResetHintR\tresetHint\x12\x1c\n\ttimestamp\x18\x0f\x20\x01(\x03R\ttimes\
    tamp\"4\n\tResetHint\x12\x0b\n\x07UNKNOWN\x10\0\x12\x07\n\x03YES\x10\x01\
    \x12\x06\n\x02NO\x10\x02\x12\t\n\x05GAUGE\x10\x03B\x07\n\x05countB\x0c\n\
    \nzero_count\"<\n\nBucketSpan\x12\x16\n\x06offset\x18\x01\x20\x01(\x11R\
    \x06offset\x12\x16\n\x06length\x18\x02\x20\x01(\rR\x06length\"\xe8\x01\n\
    \nTimeSeries\x12/\n\x06labels\x18\x01\x20\x03(\x0b2\x11.prometheus.Label\
    R\x06labelsB\x04\xc8\xde\x1f\0\x122\n\x07samples\x18\x02\x20\x03(\x0b2\
    \x12.prometheus.SampleR\x07samplesB\x04\xc8\xde\x1f\0\x128\n\texemplars\
    \x18\x03\x20\x03(\x0b2\x14.prometheus.ExemplarR\texemplarsB\x04\xc8\xde\
    \x1f\0\x12;\n\nhistograms\x18\x04\x20\x03(\x0b2\x15.prometheus.Histogram\
    R\nhistogramsB\x04\xc8\xde\x1f\0\"1\n\x05Label\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"9\
    \n\x06Labels\x12/\n\x06labels\x18\x01\x20\x03(\x0b2\x11.prometheus.Label\
    R\x06labelsB\x04\xc8\xde\x1f\0\"\x95\x01\n\x0cLabelMatcher\x121\n\x04typ\
    e\x18\x01\x20\x01(\x0e2\x1d.prometheus.LabelMatcher.TypeR\x04type\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x03\
    \x20\x01(\tR\x05value\"(\n\x04Type\x12\x06\n\x02EQ\x10\0\x12\x07\n\x03NE\
    Q\x10\x01\x12\x06\n\x02RE\x10\x02\x12\x07\n\x03NRE\x10\x03\"\xb1\x01\n\t\
    ReadHints\x12\x17\n\x07step_ms\x18\x01\x20\x01(\x03R\x06stepMs\x12\x12\n\
    \x04func\x18\x02\x20\x01(\tR\x04func\x12\x19\n\x08start_ms\x18\x03\x20\
    \x01(\x03R\x07startMs\x12\x15\n\x06end_ms\x18\x04\x20\x01(\x03R\x05endMs\
    \x12\x1a\n\x08grouping\x18\x05\x20\x03(\tR\x08grouping\x12\x0e\n\x02by\
    \x18\x06\x20\x01(\x08R\x02by\x12\x19\n\x08range_ms\x18\x07\x20\x01(\x03R\
    \x07rangeMs\"\xbc\x01\n\x05Chunk\x12\x1e\n\x0bmin_time_ms\x18\x01\x20\
    \x01(\x03R\tminTimeMs\x12\x1e\n\x0bmax_time_ms\x18\x02\x20\x01(\x03R\tma\
    xTimeMs\x12.\n\x04type\x18\x03\x20\x01(\x0e2\x1a.prometheus.Chunk.Encodi\
    ngR\x04type\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\"/\n\x08Enco\
    ding\x12\x0b\n\x07UNKNOWN\x10\0\x12\x07\n\x03XOR\x10\x01\x12\r\n\tHISTOG\
    RAM\x10\x02\"q\n\rChunkedSeries\x12/\n\x06labels\x18\x01\x20\x03(\x0b2\
    \x11.prometheus.LabelR\x06labelsB\x04\xc8\xde\x1f\0\x12/\n\x06chunks\x18\
    \x02\x20\x03(\x0b2\x11.prometheus.ChunkR\x06chunksB\x04\xc8\xde\x1f\0B\
    \x08Z\x06prompbJ\xabD\n\x07\x12\x05\r\0\xb9\x01\x01\n\xbc\x04\n\x01\x0c\
    \x12\x03\r\0\x122\xb1\x04\x20Copyright\x202017\x20Prometheus\x20Team\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20http://www.apac\
    he.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicabl\
    e\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distri\
    buted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"A\
    S\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x0e\0\x13\n\x08\n\x01\x08\x12\x03\x10\0\x1d\n\t\n\x02\x08\
    \x0b\x12\x03\x10\0\x1d\n\t\n\x02\x03\0\x12\x03\x12\0\x1e\n\n\n\x02\x04\0\
    \x12\x04\x14\0&\x01\n\n\n\x03\x04\0\x01\x12\x03\x14\x08\x16\n\x0c\n\x04\
    \x04\0\x04\0\x12\x04\x15\x02\x1e\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\
    \x15\x07\x11\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x16\x04\x17\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x01\x12\x03\x16\x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x03\x16\x15\x16\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03\x17\x04\
    \x17\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\x17\x04\x0b\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x02\x12\x03\x17\x15\x16\n\r\n\x06\x04\0\x04\0\x02\
    \x02\x12\x03\x18\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\x18\
    \x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\x18\x15\x16\n\r\n\x06\
    \x04\0\x04\0\x02\x03\x12\x03\x19\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x03\
    \x01\x12\x03\x19\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\x19\
    \x15\x16\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\x1a\x04\x17\n\x0e\n\x07\
    \x04\0\x04\0\x02\x04\x01\x12\x03\x1a\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\
    \x04\x02\x12\x03\x1a\x15\x16\n\r\n\x06\x04\0\x04\0\x02\x05\x12\x03\x1b\
    \x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x05\x01\x12\x03\x1b\x04\x0b\n\x0e\n\
    \x07\x04\0\x04\0\x02\x05\x02\x12\x03\x1b\x15\x16\n\r\n\x06\x04\0\x04\0\
    \x02\x06\x12\x03\x1c\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x06\x01\x12\x03\
    \x1c\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x06\x02\x12\x03\x1c\x15\x16\n\r\
    \n\x06\x04\0\x04\0\x02\x07\x12\x03\x1d\x04\x17\n\x0e\n\x07\x04\0\x04\0\
    \x02\x07\x01\x12\x03\x1d\x04\x0c\n\x0e\n\x07\x04\0\x04\0\x02\x07\x02\x12\
    \x03\x1d\x15\x16\n\x83\x01\n\x04\x04\0\x02\0\x12\x03\"\x02\x16\x1av\x20R\
    epresents\x20the\x20metric\x20type,\x20these\x20match\x20the\x20set\x20f\
    rom\x20Prometheus.\n\x20Refer\x20to\x20model/textparse/interface.go\x20f\
    or\x20details.\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\"\x02\x0c\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\"\r\x11\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \"\x14\x15\n\x0b\n\x04\x04\0\x02\x01\x12\x03#\x02\x20\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03#\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03#\t\
    \x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03#\x1e\x1f\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x03$\x02\x12\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03$\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03$\t\r\n\x0c\n\x05\x04\0\x02\x02\
    \x03\x12\x03$\x10\x11\n\x0b\n\x04\x04\0\x02\x03\x12\x03%\x02\x12\n\x0c\n\
    \x05\x04\0\x02\x03\x05\x12\x03%\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03%\t\r\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03%\x10\x11\n\n\n\x02\
    \x04\x01\x12\x04(\0-\x01\n\n\n\x03\x04\x01\x01\x12\x03(\x08\x0e\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03)\x02\x16\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03)\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03)\t\x0e\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03)\x14\x15\n\x82\x01\n\x04\x04\x01\x02\x01\x12\
    \x03,\x02\x16\x1au\x20timestamp\x20is\x20in\x20ms\x20format,\x20see\x20m\
    odel/timestamp/timestamp.go\x20for\n\x20conversion\x20from\x20time.Time\
    \x20to\x20Prometheus\x20timestamp.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\
    \x03,\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03,\x08\x11\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03,\x14\x15\n\n\n\x02\x04\x02\x12\x04/\06\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03/\x08\x10\n&\n\x04\x04\x02\x02\0\x12\
    \x031\x02;\x1a\x19\x20Optional,\x20can\x20be\x20empty.\n\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x031\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x031\x0b\
    \x10\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x031\x11\x17\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x031\x1a\x1b\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x031\x1c:\
    \n\x0f\n\x08\x04\x02\x02\0\x08\xe9\xfb\x03\x12\x031\x1d9\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x032\x02\x13\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x032\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x032\t\x0e\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x032\x11\x12\n\x82\x01\n\x04\x04\x02\x02\x02\x12\
    \x035\x02\x16\x1au\x20timestamp\x20is\x20in\x20ms\x20format,\x20see\x20m\
    odel/timestamp/timestamp.go\x20for\n\x20conversion\x20from\x20time.Time\
    \x20to\x20Prometheus\x20timestamp.\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\
    \x035\x02\x07\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x035\x08\x11\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x035\x14\x15\n\xe7\x02\n\x02\x04\x03\x12\
    \x04>\0m\x01\x1a\xda\x02\x20A\x20native\x20histogram,\x20also\x20known\
    \x20as\x20a\x20sparse\x20histogram.\n\x20Original\x20design\x20doc:\n\
    \x20https://docs.google.com/document/d/1cLNv3aufPZb3fNfaJgdaRBZsInZKKIHo\
    9E6HinJVbpM/edit\n\x20The\x20appendix\x20of\x20this\x20design\x20doc\x20\
    also\x20explains\x20the\x20concept\x20of\x20float\n\x20histograms.\x20Th\
    is\x20Histogram\x20message\x20can\x20represent\x20both,\x20the\x20usual\
    \n\x20integer\x20histogram\x20as\x20well\x20as\x20a\x20float\x20histogra\
    m.\n\n\n\n\x03\x04\x03\x01\x12\x03>\x08\x11\n\x0c\n\x04\x04\x03\x04\0\
    \x12\x04?\x02D\x03\n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03?\x07\x10\n=\n\
    \x06\x04\x03\x04\0\x02\0\x12\x03@\x04\x10\".\x20Need\x20to\x20test\x20fo\
    r\x20a\x20counter\x20reset\x20explicitly.\n\n\x0e\n\x07\x04\x03\x04\0\
    \x02\0\x01\x12\x03@\x04\x0b\n\x0e\n\x07\x04\x03\x04\0\x02\0\x02\x12\x03@\
    \x0e\x0f\nA\n\x06\x04\x03\x04\0\x02\x01\x12\x03A\x04\x10\"2\x20This\x20i\
    s\x20the\x201st\x20histogram\x20after\x20a\x20counter\x20reset.\n\n\x0e\
    \n\x07\x04\x03\x04\0\x02\x01\x01\x12\x03A\x04\x07\n\x0e\n\x07\x04\x03\
    \x04\0\x02\x01\x02\x12\x03A\x0e\x0f\nT\n\x06\x04\x03\x04\0\x02\x02\x12\
    \x03B\x04\x10\"E\x20There\x20was\x20no\x20counter\x20reset\x20between\
    \x20this\x20and\x20the\x20previous\x20Histogram.\n\n\x0e\n\x07\x04\x03\
    \x04\0\x02\x02\x01\x12\x03B\x04\x06\n\x0e\n\x07\x04\x03\x04\0\x02\x02\
    \x02\x12\x03B\x0e\x0f\nM\n\x06\x04\x03\x04\0\x02\x03\x12\x03C\x04\x10\">\
    \x20This\x20is\x20a\x20gauge\x20histogram\x20where\x20counter\x20resets\
    \x20don't\x20happen.\n\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x01\x12\x03C\
    \x04\t\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x02\x12\x03C\x0e\x0f\n7\n\x04\
    \x04\x03\x08\0\x12\x04F\x02I\x03\")\x20Count\x20of\x20observations\x20in\
    \x20the\x20histogram.\n\n\x0c\n\x05\x04\x03\x08\0\x01\x12\x03F\x08\r\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03G\x04\x1b\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03G\x04\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03G\x0b\x14\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03G\x19\x1a\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x03H\x04\x1b\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03H\x04\n\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03H\x0b\x16\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03H\x19\x1a\n4\n\x04\x04\x03\x02\x02\x12\x03J\x02\x11\"'\x20Sum\
    \x20of\x20observations\x20in\x20the\x20histogram.\n\n\x0c\n\x05\x04\x03\
    \x02\x02\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03J\t\
    \x0c\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03J\x0f\x10\n\x99\x03\n\x04\
    \x04\x03\x02\x03\x12\x03R\x02\x20\x1a\x8b\x03\x20The\x20schema\x20define\
    s\x20the\x20bucket\x20schema.\x20Currently,\x20valid\x20numbers\n\x20are\
    \x20-4\x20<=\x20n\x20<=\x208.\x20They\x20are\x20all\x20for\x20base-2\x20\
    bucket\x20schemas,\x20where\x201\n\x20is\x20a\x20bucket\x20boundary\x20i\
    n\x20each\x20case,\x20and\x20then\x20each\x20power\x20of\x20two\x20is\n\
    \x20divided\x20into\x202^n\x20logarithmic\x20buckets.\x20Or\x20in\x20oth\
    er\x20words,\x20each\n\x20bucket\x20boundary\x20is\x20the\x20previous\
    \x20boundary\x20times\x202^(2^-n).\x20In\x20the\n\x20future,\x20more\x20\
    bucket\x20schemas\x20may\x20be\x20added\x20using\x20numbers\x20<\x20-4\
    \x20or\x20>\n\x208.\n\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03R\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03R\t\x0f\n\x0c\n\x05\x04\x03\x02\
    \x03\x03\x12\x03R\x1e\x1f\n*\n\x04\x04\x03\x02\x04\x12\x03S\x02\x20\"\
    \x1d\x20Breadth\x20of\x20the\x20zero\x20bucket.\n\n\x0c\n\x05\x04\x03\
    \x02\x04\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03S\t\
    \x17\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03S\x1e\x1f\n%\n\x04\x04\x03\
    \x08\x01\x12\x04T\x02W\x03\"\x17\x20Count\x20in\x20zero\x20bucket.\n\n\
    \x0c\n\x05\x04\x03\x08\x01\x01\x12\x03T\x08\x12\n\x0b\n\x04\x04\x03\x02\
    \x05\x12\x03U\x04\"\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03U\x04\n\n\x0c\
    \n\x05\x04\x03\x02\x05\x01\x12\x03U\x0b\x19\n\x0c\n\x05\x04\x03\x02\x05\
    \x03\x12\x03U\x20!\n\x0b\n\x04\x04\x03\x02\x06\x12\x03V\x04\"\n\x0c\n\
    \x05\x04\x03\x02\x06\x05\x12\x03V\x04\n\n\x0c\n\x05\x04\x03\x02\x06\x01\
    \x12\x03V\x0b\x1b\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03V\x20!\n\x20\n\
    \x04\x04\x03\x02\x07\x12\x03Z\x02*\x1a\x13\x20Negative\x20Buckets.\n\n\
    \x0c\n\x05\x04\x03\x02\x07\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\x03\x02\
    \x07\x06\x12\x03Z\x0b\x15\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03Z\x16$\
    \n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03Z()\n\xf0\x01\n\x04\x04\x03\x02\
    \x08\x12\x03^\x02*\x1a\x8e\x01\x20Use\x20either\x20\"negative_deltas\"\
    \x20or\x20\"negative_counts\",\x20the\x20former\x20for\n\x20regular\x20h\
    istograms\x20with\x20integer\x20counts,\x20the\x20latter\x20for\x20float\
    \n\x20histograms.\n\"R\x20Count\x20delta\x20of\x20each\x20bucket\x20comp\
    ared\x20to\x20previous\x20one\x20(or\x20to\x20zero\x20for\x201st\x20buck\
    et).\n\n\x0c\n\x05\x04\x03\x02\x08\x04\x12\x03^\x02\n\n\x0c\n\x05\x04\
    \x03\x02\x08\x05\x12\x03^\x0b\x11\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\
    \x03^\x12!\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\x03^()\n-\n\x04\x04\x03\
    \x02\t\x12\x03_\x02*\"\x20\x20Absolute\x20count\x20of\x20each\x20bucket.\
    \n\n\x0c\n\x05\x04\x03\x02\t\x04\x12\x03_\x02\n\n\x0c\n\x05\x04\x03\x02\
    \t\x05\x12\x03_\x0b\x11\n\x0c\n\x05\x04\x03\x02\t\x01\x12\x03_\x12!\n\
    \x0c\n\x05\x04\x03\x02\t\x03\x12\x03_')\n\x20\n\x04\x04\x03\x02\n\x12\
    \x03b\x02*\x1a\x13\x20Positive\x20Buckets.\n\n\x0c\n\x05\x04\x03\x02\n\
    \x04\x12\x03b\x02\n\n\x0c\n\x05\x04\x03\x02\n\x06\x12\x03b\x0b\x15\n\x0c\
    \n\x05\x04\x03\x02\n\x01\x12\x03b\x16$\n\x0c\n\x05\x04\x03\x02\n\x03\x12\
    \x03b')\n\xf0\x01\n\x04\x04\x03\x02\x0b\x12\x03f\x02*\x1a\x8e\x01\x20Use\
    \x20either\x20\"positive_deltas\"\x20or\x20\"positive_counts\",\x20the\
    \x20former\x20for\n\x20regular\x20histograms\x20with\x20integer\x20count\
    s,\x20the\x20latter\x20for\x20float\n\x20histograms.\n\"R\x20Count\x20de\
    lta\x20of\x20each\x20bucket\x20compared\x20to\x20previous\x20one\x20(or\
    \x20to\x20zero\x20for\x201st\x20bucket).\n\n\x0c\n\x05\x04\x03\x02\x0b\
    \x04\x12\x03f\x02\n\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03f\x0b\x11\n\
    \x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03f\x12!\n\x0c\n\x05\x04\x03\x02\x0b\
    \x03\x12\x03f')\n-\n\x04\x04\x03\x02\x0c\x12\x03g\x02*\"\x20\x20Absolute\
    \x20count\x20of\x20each\x20bucket.\n\n\x0c\n\x05\x04\x03\x02\x0c\x04\x12\
    \x03g\x02\n\n\x0c\n\x05\x04\x03\x02\x0c\x05\x12\x03g\x0b\x11\n\x0c\n\x05\
    \x04\x03\x02\x0c\x01\x12\x03g\x12!\n\x0c\n\x05\x04\x03\x02\x0c\x03\x12\
    \x03g')\n\x0b\n\x04\x04\x03\x02\r\x12\x03i\x02*\n\x0c\n\x05\x04\x03\x02\
    \r\x06\x12\x03i\x02\x0b\n\x0c\n\x05\x04\x03\x02\r\x01\x12\x03i\x0c\x16\n\
    \x0c\n\x05\x04\x03\x02\r\x03\x12\x03i')\n\x82\x01\n\x04\x04\x03\x02\x0e\
    \x12\x03l\x02\x17\x1au\x20timestamp\x20is\x20in\x20ms\x20format,\x20see\
    \x20model/timestamp/timestamp.go\x20for\n\x20conversion\x20from\x20time.\
    Time\x20to\x20Prometheus\x20timestamp.\n\n\x0c\n\x05\x04\x03\x02\x0e\x05\
    \x12\x03l\x02\x07\n\x0c\n\x05\x04\x03\x02\x0e\x01\x12\x03l\x08\x11\n\x0c\
    \n\x05\x04\x03\x02\x0e\x03\x12\x03l\x14\x16\n\xce\x02\n\x02\x04\x04\x12\
    \x04t\0w\x01\x1a\xc1\x02\x20A\x20BucketSpan\x20defines\x20a\x20number\
    \x20of\x20consecutive\x20buckets\x20with\x20their\n\x20offset.\x20Logica\
    lly,\x20it\x20would\x20be\x20more\x20straightforward\x20to\x20include\
    \x20the\n\x20bucket\x20counts\x20in\x20the\x20Span.\x20However,\x20the\
    \x20protobuf\x20representation\x20is\n\x20more\x20compact\x20in\x20the\
    \x20way\x20the\x20data\x20is\x20structured\x20here\x20(with\x20all\x20th\
    e\n\x20buckets\x20in\x20a\x20single\x20array\x20separate\x20from\x20the\
    \x20Spans).\n\n\n\n\x03\x04\x04\x01\x12\x03t\x08\x12\n\\\n\x04\x04\x04\
    \x02\0\x12\x03u\x02\x14\"O\x20Gap\x20to\x20previous\x20span,\x20or\x20st\
    arting\x20point\x20for\x201st\x20span\x20(which\x20can\x20be\x20negative\
    ).\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03u\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x03u\t\x0f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03u\x12\x13\
    \n-\n\x04\x04\x04\x02\x01\x12\x03v\x02\x14\"\x20\x20Length\x20of\x20cons\
    ecutive\x20buckets.\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03v\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03v\t\x0f\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03v\x12\x13\nQ\n\x02\x04\x05\x12\x05z\0\x81\x01\x01\x1aD\
    \x20TimeSeries\x20represents\x20samples\x20and\x20labels\x20for\x20a\x20\
    single\x20time\x20series.\n\n\n\n\x03\x04\x05\x01\x12\x03z\x08\x12\n\x9c\
    \x01\n\x04\x04\x05\x02\0\x12\x03}\x02C\x1a\x8e\x01\x20For\x20a\x20timese\
    ries\x20to\x20be\x20valid,\x20and\x20for\x20the\x20samples\x20and\x20exe\
    mplars\n\x20to\x20be\x20ingested\x20by\x20the\x20remote\x20system\x20pro\
    perly,\x20the\x20labels\x20field\x20is\x20required.\n\n\x0c\n\x05\x04\
    \x05\x02\0\x04\x12\x03}\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03}\x0b\
    \x10\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03}\x11\x17\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03}\"#\n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03}$B\n\x0f\n\
    \x08\x04\x05\x02\0\x08\xe9\xfb\x03\x12\x03}%A\n\x0b\n\x04\x04\x05\x02\
    \x01\x12\x03~\x02C\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03~\x02\n\n\x0c\
    \n\x05\x04\x05\x02\x01\x06\x12\x03~\x0b\x11\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03~\x12\x19\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03~\"#\n\x0c\
    \n\x05\x04\x05\x02\x01\x08\x12\x03~$B\n\x0f\n\x08\x04\x05\x02\x01\x08\
    \xe9\xfb\x03\x12\x03~%A\n\x0b\n\x04\x04\x05\x02\x02\x12\x03\x7f\x02C\n\
    \x0c\n\x05\x04\x05\x02\x02\x04\x12\x03\x7f\x02\n\n\x0c\n\x05\x04\x05\x02\
    \x02\x06\x12\x03\x7f\x0b\x13\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03\x7f\
    \x14\x1d\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03\x7f\"#\n\x0c\n\x05\x04\
    \x05\x02\x02\x08\x12\x03\x7f$B\n\x0f\n\x08\x04\x05\x02\x02\x08\xe9\xfb\
    \x03\x12\x03\x7f%A\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\x80\x01\x02C\n\r\
    \n\x05\x04\x05\x02\x03\x04\x12\x04\x80\x01\x02\n\n\r\n\x05\x04\x05\x02\
    \x03\x06\x12\x04\x80\x01\x0b\x14\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\
    \x80\x01\x15\x1f\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x80\x01\"#\n\r\n\
    \x05\x04\x05\x02\x03\x08\x12\x04\x80\x01$B\n\x10\n\x08\x04\x05\x02\x03\
    \x08\xe9\xfb\x03\x12\x04\x80\x01%A\n\x0c\n\x02\x04\x06\x12\x06\x83\x01\0\
    \x86\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x83\x01\x08\r\n\x0c\n\x04\
    \x04\x06\x02\0\x12\x04\x84\x01\x02\x13\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\x84\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x84\x01\t\r\n\r\
    \n\x05\x04\x06\x02\0\x03\x12\x04\x84\x01\x11\x12\n\x0c\n\x04\x04\x06\x02\
    \x01\x12\x04\x85\x01\x02\x13\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x85\
    \x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x85\x01\t\x0e\n\r\n\
    \x05\x04\x06\x02\x01\x03\x12\x04\x85\x01\x11\x12\n\x0c\n\x02\x04\x07\x12\
    \x06\x88\x01\0\x8a\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x88\x01\x08\
    \x0e\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x89\x01\x02;\n\r\n\x05\x04\x07\
    \x02\0\x04\x12\x04\x89\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x89\
    \x01\x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x89\x01\x11\x17\n\r\n\
    \x05\x04\x07\x02\0\x03\x12\x04\x89\x01\x1a\x1b\n\r\n\x05\x04\x07\x02\0\
    \x08\x12\x04\x89\x01\x1c:\n\x10\n\x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\
    \x04\x89\x01\x1d9\nR\n\x02\x04\x08\x12\x06\x8d\x01\0\x97\x01\x01\x1aD\
    \x20Matcher\x20specifies\x20a\x20rule,\x20which\x20can\x20match\x20or\
    \x20set\x20of\x20labels\x20or\x20not.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \x8d\x01\x08\x14\n\x0e\n\x04\x04\x08\x04\0\x12\x06\x8e\x01\x02\x93\x01\
    \x03\n\r\n\x05\x04\x08\x04\0\x01\x12\x04\x8e\x01\x07\x0b\n\x0e\n\x06\x04\
    \x08\x04\0\x02\0\x12\x04\x8f\x01\x04\x0c\n\x0f\n\x07\x04\x08\x04\0\x02\0\
    \x01\x12\x04\x8f\x01\x04\x06\n\x0f\n\x07\x04\x08\x04\0\x02\0\x02\x12\x04\
    \x8f\x01\n\x0b\n\x0e\n\x06\x04\x08\x04\0\x02\x01\x12\x04\x90\x01\x04\x0c\
    \n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\x90\x01\x04\x07\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x01\x02\x12\x04\x90\x01\n\x0b\n\x0e\n\x06\x04\x08\
    \x04\0\x02\x02\x12\x04\x91\x01\x04\x0c\n\x0f\n\x07\x04\x08\x04\0\x02\x02\
    \x01\x12\x04\x91\x01\x04\x06\n\x0f\n\x07\x04\x08\x04\0\x02\x02\x02\x12\
    \x04\x91\x01\n\x0b\n\x0e\n\x06\x04\x08\x04\0\x02\x03\x12\x04\x92\x01\x04\
    \x0c\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x04\x92\x01\x04\x07\n\x0f\
    \n\x07\x04\x08\x04\0\x02\x03\x02\x12\x04\x92\x01\n\x0b\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\x94\x01\x02\x13\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\
    \x94\x01\x02\x06\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x94\x01\x07\x0b\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\x94\x01\x11\x12\n\x0c\n\x04\x04\x08\x02\
    \x01\x12\x04\x95\x01\x02\x13\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x95\
    \x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x95\x01\t\r\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\x95\x01\x11\x12\n\x0c\n\x04\x04\x08\x02\x02\
    \x12\x04\x96\x01\x02\x13\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x96\x01\
    \x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x96\x01\t\x0e\n\r\n\x05\
    \x04\x08\x02\x02\x03\x12\x04\x96\x01\x11\x12\n\x0c\n\x02\x04\t\x12\x06\
    \x99\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x99\x01\x08\x11\n0\
    \n\x04\x04\t\x02\0\x12\x04\x9a\x01\x02\x14\"\"\x20Query\x20step\x20size\
    \x20in\x20milliseconds.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x9a\x01\x02\
    \x07\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x9a\x01\x08\x0f\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\x9a\x01\x12\x13\nM\n\x04\x04\t\x02\x01\x12\x04\x9b\
    \x01\x02\x12\"?\x20String\x20representation\x20of\x20surrounding\x20func\
    tion\x20or\x20aggregation.\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x9b\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x9b\x01\t\r\n\r\n\x05\x04\t\
    \x02\x01\x03\x12\x04\x9b\x01\x10\x11\n+\n\x04\x04\t\x02\x02\x12\x04\x9c\
    \x01\x02\x15\"\x1d\x20Start\x20time\x20in\x20milliseconds.\n\n\r\n\x05\
    \x04\t\x02\x02\x05\x12\x04\x9c\x01\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\
    \x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x9c\x01\x13\
    \x14\n)\n\x04\x04\t\x02\x03\x12\x04\x9d\x01\x02\x13\"\x1b\x20End\x20time\
    \x20in\x20milliseconds.\n\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\x9d\x01\
    \x02\x07\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x9d\x01\x08\x0e\n\r\n\x05\
    \x04\t\x02\x03\x03\x12\x04\x9d\x01\x11\x12\n8\n\x04\x04\t\x02\x04\x12\
    \x04\x9e\x01\x02\x1f\"*\x20List\x20of\x20label\x20names\x20used\x20in\
    \x20aggregation.\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\x9e\x01\x02\n\n\r\
    \n\x05\x04\t\x02\x04\x05\x12\x04\x9e\x01\x0b\x11\n\r\n\x05\x04\t\x02\x04\
    \x01\x12\x04\x9e\x01\x12\x1a\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\x9e\x01\
    \x1d\x1e\n5\n\x04\x04\t\x02\x05\x12\x04\x9f\x01\x02\x0e\"'\x20Indicate\
    \x20whether\x20it\x20is\x20without\x20or\x20by.\n\n\r\n\x05\x04\t\x02\
    \x05\x05\x12\x04\x9f\x01\x02\x06\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\x9f\
    \x01\x07\t\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\x9f\x01\x0c\r\n<\n\x04\
    \x04\t\x02\x06\x12\x04\xa0\x01\x02\x15\".\x20Range\x20vector\x20selector\
    \x20range\x20in\x20milliseconds.\n\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\
    \xa0\x01\x02\x07\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xa0\x01\x08\x10\n\r\
    \n\x05\x04\t\x02\x06\x03\x12\x04\xa0\x01\x13\x14\nS\n\x02\x04\n\x12\x06\
    \xa5\x01\0\xb1\x01\x01\x1aE\x20Chunk\x20represents\x20a\x20TSDB\x20chunk\
    .\n\x20Time\x20range\x20[min,\x20max]\x20is\x20inclusive.\n\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xa5\x01\x08\r\n\x0c\n\x04\x04\n\x02\0\x12\x04\xa6\x01\
    \x02\x18\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xa6\x01\x02\x07\n\r\n\x05\x04\
    \n\x02\0\x01\x12\x04\xa6\x01\x08\x13\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xa6\x01\x16\x17\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xa7\x01\x02\x18\n\r\n\
    \x05\x04\n\x02\x01\x05\x12\x04\xa7\x01\x02\x07\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xa7\x01\x08\x13\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xa7\x01\
    \x16\x17\n=\n\x04\x04\n\x04\0\x12\x06\xaa\x01\x02\xae\x01\x03\x1a-\x20We\
    \x20require\x20this\x20to\x20match\x20chunkenc.Encoding.\n\n\r\n\x05\x04\
    \n\x04\0\x01\x12\x04\xaa\x01\x07\x0f\n\x0e\n\x06\x04\n\x04\0\x02\0\x12\
    \x04\xab\x01\x04\x12\n\x0f\n\x07\x04\n\x04\0\x02\0\x01\x12\x04\xab\x01\
    \x04\x0b\n\x0f\n\x07\x04\n\x04\0\x02\0\x02\x12\x04\xab\x01\x10\x11\n\x0e\
    \n\x06\x04\n\x04\0\x02\x01\x12\x04\xac\x01\x04\x12\n\x0f\n\x07\x04\n\x04\
    \0\x02\x01\x01\x12\x04\xac\x01\x04\x07\n\x0f\n\x07\x04\n\x04\0\x02\x01\
    \x02\x12\x04\xac\x01\x10\x11\n\x0e\n\x06\x04\n\x04\0\x02\x02\x12\x04\xad\
    \x01\x04\x12\n\x0f\n\x07\x04\n\x04\0\x02\x02\x01\x12\x04\xad\x01\x04\r\n\
    \x0f\n\x07\x04\n\x04\0\x02\x02\x02\x12\x04\xad\x01\x10\x11\n\x0c\n\x04\
    \x04\n\x02\x02\x12\x04\xaf\x01\x02\x15\n\r\n\x05\x04\n\x02\x02\x06\x12\
    \x04\xaf\x01\x02\n\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xaf\x01\x0b\x0f\n\
    \r\n\x05\x04\n\x02\x02\x03\x12\x04\xaf\x01\x13\x14\n\x0c\n\x04\x04\n\x02\
    \x03\x12\x04\xb0\x01\x02\x15\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xb0\x01\
    \x02\x07\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xb0\x01\x08\x0c\n\r\n\x05\
    \x04\n\x02\x03\x03\x12\x04\xb0\x01\x13\x14\nE\n\x02\x04\x0b\x12\x06\xb4\
    \x01\0\xb9\x01\x01\x1a7\x20ChunkedSeries\x20represents\x20single,\x20enc\
    oded\x20time\x20series.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb4\x01\x08\
    \x15\n(\n\x04\x04\x0b\x02\0\x12\x04\xb6\x01\x02;\x1a\x1a\x20Labels\x20sh\
    ould\x20be\x20sorted.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb6\x01\x02\
    \n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xb6\x01\x0b\x10\n\r\n\x05\x04\x0b\
    \x02\0\x01\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \xb6\x01\x1a\x1b\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\xb6\x01\x1c:\n\x10\
    \n\x08\x04\x0b\x02\0\x08\xe9\xfb\x03\x12\x04\xb6\x01\x1d9\nC\n\x04\x04\
    \x0b\x02\x01\x12\x04\xb8\x01\x02;\x1a5\x20Chunks\x20will\x20be\x20in\x20\
    start\x20time\x20order\x20and\x20may\x20overlap.\n\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xb8\
    \x01\x0b\x10\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xb8\x01\x11\x17\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\xb8\x01\x1a\x1b\n\r\n\x05\x04\x0b\x02\
    \x01\x08\x12\x04\xb8\x01\x1c:\n\x10\n\x08\x04\x0b\x02\x01\x08\xe9\xfb\
    \x03\x12\x04\xb8\x01\x1d9b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(MetricMetadata::generated_message_descriptor_data());
            messages.push(Sample::generated_message_descriptor_data());
            messages.push(Exemplar::generated_message_descriptor_data());
            messages.push(Histogram::generated_message_descriptor_data());
            messages.push(BucketSpan::generated_message_descriptor_data());
            messages.push(TimeSeries::generated_message_descriptor_data());
            messages.push(Label::generated_message_descriptor_data());
            messages.push(Labels::generated_message_descriptor_data());
            messages.push(LabelMatcher::generated_message_descriptor_data());
            messages.push(ReadHints::generated_message_descriptor_data());
            messages.push(Chunk::generated_message_descriptor_data());
            messages.push(ChunkedSeries::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(metric_metadata::MetricType::generated_enum_descriptor_data());
            enums.push(histogram::ResetHint::generated_enum_descriptor_data());
            enums.push(label_matcher::Type::generated_enum_descriptor_data());
            enums.push(chunk::Encoding::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
